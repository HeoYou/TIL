# ORM 객체 관계 매핑

객체와 관계형 데이터베이스의 데이터를 자동으로 매핑(연결) 해주는 Framework



## ORM이란

- 객체와 관계형 데이터베이스의 데이터를 자동으로 매핑하는것을 의미
  - 객체 지향 프로그램은 클래스를 사용, 관계형 데이터베이스는 테이블을 사용.
  - 객체 모델과 관계형 모델 간의 불일치가 존재.(불일치가 생기는 이유도 잘모름)
  - ORM을 통해 객체 간의 관계를 바탕으로 SQL을 자동으로 생성하여 불일치를 해결.?? (이건 잘 모르겠다.)
- 데이터베이스 <- 매핑 -> Object필드
  - 객체를 통해 간접적으로 데이터베이스를 다룬다.
- Persistant API라고도한다
  - ex) JPA, Hibernate 등



### ORM의 장점

- 객체지향적 코드로 인해 더 직관적이고 비즈니스 로직에 더 집중할 수 있게 도와준다.
  - ORM을 이용하면  SQL이 클래스의 메서드로 데이터를 조작할 수 있어 개발자가 객체 모델로 프로그래밍하는 데 집중할 수 있다.
  - 선언문, 할당, 종료 같은 부수적인 코드가 없거나 줄어듬
  - 객체마다 코드를 별도 작성하기 때문에 코드 가독성이 높아진다
  - SQL은 절차적이고 순차적인 접근을 한다. 반면 ORM은 객체지향적 접근으로 인해 생산성을 높여준다.
- 재사용 및 유지보수의 편리성이 증가
  - ORM은 독립적이기 때문에 해당 객체들을 재활용할 수 있다.
  - 매핑 정보가 명확하여, ERD에 대한 의존도를 낮춘다.
- DBMS에 대한 종속성이 줄어든다
  - 객체 간의 관계를 바탕으로 SQL을 자동 생성하기 때문에 RDB의 데이터 구조와 객체지향 모델 사이의 간격을 좁힌다.
  - 대부분 ORM은 DB에 종속적이지 않다.
  - 종속적이지 않기 때문에 구현 방법 뿐만아니라 다양한 솔루션에서 자료형 타입까지 유효하다.
  - 프로그래머가 Object에 집중함으로 DBMS를 교체하는 작업에도 비교적 적은 리스크와 시간이 소요.
  - JAVA에서 equals, hashcode의 오버라이드 같은 자바의 기능을 이용할 수 있어 간결하고 빠른 가공이 가능



### ORM의 단점

- 완벽한 ORM으로 서비스를 구현하기 힘들다.
  - 사용하기는 편하지만 설계는 매우 신중하게 해야한다.
  - 프로젝트의 복잡성이 커질수록 난이도 또한 증가
  - 잘못 구현된 경우 속도 저하 및 심각할 경우 일관성이 무너지는 문제점 발생
  - 일부 자주 사용되는 대형 쿼리는 속도를 위해 SP를 쓰는 등 별도의 튜닝이 필요하다.
  - DBMS의 고유 기능을 이용하기 어렵다.(단점으로만 볼 수 없다 : 특정 DBMS의 고유기능을 이용하면 이식성이 저하된다.)
- 프로시저가 많은 시스템에선 ORM의 객체 지향적 장점을 활용하기 어렵다.
  - 프로시저가 많은 시스템에서 다시 객체로 바꿔야하며, 그 과정에서 생산성 저하나 리스크가 많이 발생할 수 있다.



### 객체 모델과 관계형 모델 간의 불일치(패러다임 불일치)

객체와 DB와는 차이가 있을 수 밖에 없다. DB는 철저히 데이터 중심으로 설계되어 있으며, 객체와 DB 목적이 다르다. **패러다임의 불일치는 이렇게 객체(OOP)와 관계형 DB의 데이터 표현방식과 다루는 방법이 달라 일어나는 현상이다.**

객체와 DB 양쪽의 불일치를 해결해줘야 한다. 그렇지 않다면 DB에 의존적이게 코딩을 하게 될 수 밖에 없다.



#### 1. 밀도(Granularity)문제

